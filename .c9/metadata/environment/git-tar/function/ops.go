{"changed":false,"filter":false,"title":"ops.go","tooltip":"/git-tar/function/ops.go","value":"package function\n\nimport (\n\t\"archive/tar\"\n\t\"bytes\"\n\t\"encoding/hex\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/ioutil\"\n\t\"log\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"os\"\n\t\"os/exec\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strconv\"\n\t\"strings\"\n\n\t\"code.cloudfoundry.org/bytefmt\"\n\t\"github.com/openfaas/faas-cli/schema\"\n\n\t\"github.com/alexellis/derek/auth\"\n\t\"github.com/alexellis/hmac\"\n\t\"github.com/openfaas/faas-cli/stack\"\n\t\"github.com/openfaas/openfaas-cloud/sdk\"\n)\n\n// ConfigFileName for Docker bundle\nconst ConfigFileName = \"com.openfaas.docker.config\"\n\ntype tarEntry struct {\n\tfileName     string\n\tfunctionName string\n\timageName    string\n}\n\ntype cfg struct {\n\tRef      string  `json:\"ref\"`\n\tFrontend *string `json:\"frontend,omitempty\"`\n}\n\nfunc parseYAML(pushEvent sdk.PushEvent, filePath string) (*stack.Services, error) {\n\tenvVarSubst := false\n\tparsed, err := stack.ParseYAMLFile(path.Join(filePath, \"stack.yml\"), \"\", \"\", envVarSubst)\n\treturn parsed, err\n}\n\nfunc fetchTemplates(filePath string) error {\n\ttemplateRepos := formatTemplateRepos()\n\n\tfor _, repo := range templateRepos {\n\t\tpullCmd := exec.Command(\"faas-cli\", \"template\", \"pull\", repo)\n\t\tpullCmd.Dir = filePath\n\t\terr := pullCmd.Start()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to start faas-cli template pull: %t\", err)\n\t\t}\n\t\terr = pullCmd.Wait()\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"Failed to wait faas-cli template pull: %t\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n\nfunc shrinkwrap(pushEvent sdk.PushEvent, filePath string) (string, error) {\n\tbuildCmd := exec.Command(\"faas-cli\", \"build\", \"-f\", \"stack.yml\", \"--shrinkwrap\")\n\tbuildCmd.Dir = filePath\n\terr := buildCmd.Start()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Cannot start faas-cli build: %t\", err)\n\t}\n\terr = buildCmd.Wait()\n\n\treturn filePath, err\n}\n\nfunc makeTar(pushEvent sdk.PushEvent, filePath string, services *stack.Services) ([]tarEntry, error) {\n\ttars := []tarEntry{}\n\n\tfmt.Printf(\"Tar up %s\\n\", filePath)\n\n\tfor k, v := range services.Functions {\n\t\tfmt.Println(\"Creating tar for: \", v.Handler, k)\n\n\t\ttarPath := path.Join(filePath, fmt.Sprintf(\"%s.tar\", k))\n\t\tcontextTar, err := os.Create(tarPath)\n\t\tif err != nil {\n\t\t\treturn []tarEntry{}, err\n\t\t}\n\n\t\ttarWriter := tar.NewWriter(contextTar)\n\t\tdefer tarWriter.Close()\n\n\t\tbase := filepath.Join(filePath, filepath.Join(\"build\", k))\n\n\t\tpushRepositoryURL := os.Getenv(\"push_repository_url\")\n\n\t\tif len(pushRepositoryURL) == 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"push_repository_url env-var not set\")\n\t\t\treturn nil, fmt.Errorf(\"push_repository_url env-var not set\")\n\t\t}\n\n\t\timageName := formatImageShaTag(pushRepositoryURL, &v, pushEvent.AfterCommitID,\n\t\t\tpushEvent.Repository.Owner.Login, pushEvent.Repository.Name)\n\n\t\tconfig := cfg{\n\t\t\tRef: imageName,\n\t\t}\n\n\t\tconfigBytes, _ := json.Marshal(config)\n\t\tconfigErr := ioutil.WriteFile(path.Join(base, ConfigFileName), configBytes, 0600)\n\t\tif configErr != nil {\n\t\t\treturn nil, configErr\n\t\t}\n\n\t\terr = filepath.Walk(base, func(path string, f os.FileInfo, pathErr error) error {\n\t\t\tif pathErr != nil {\n\t\t\t\treturn pathErr\n\t\t\t}\n\n\t\t\tif f.Name() == \"context.tar\" {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\ttargetFile, err1 := os.Open(path)\n\t\t\tlog.Println(path)\n\n\t\t\tif err1 != nil {\n\t\t\t\treturn err1\n\t\t\t}\n\n\t\t\theader, headerErr := tar.FileInfoHeader(f, f.Name())\n\t\t\tif headerErr != nil {\n\t\t\t\treturn headerErr\n\t\t\t}\n\n\t\t\theader.Name = strings.TrimPrefix(path, base)\n\t\t\tif header.Name != fmt.Sprintf(\"/%s\", ConfigFileName) {\n\t\t\t\theader.Name = filepath.Join(\"context\", header.Name)\n\t\t\t}\n\n\t\t\theader.Name = strings.TrimPrefix(header.Name, \"/\")\n\n\t\t\tif err1 = tarWriter.WriteHeader(header); err != nil {\n\t\t\t\treturn err1\n\t\t\t}\n\n\t\t\tif f.Mode().IsDir() {\n\t\t\t\treturn nil\n\t\t\t}\n\n\t\t\t_, err1 = io.Copy(tarWriter, targetFile)\n\t\t\treturn err1\n\t\t})\n\n\t\tif err != nil {\n\t\t\treturn []tarEntry{}, err\n\t\t}\n\n\t\ttars = append(tars,\n\t\t\ttarEntry{fileName: tarPath,\n\t\t\t\tfunctionName: strings.TrimSpace(k),\n\t\t\t\timageName:    imageName,\n\t\t\t})\n\t}\n\n\treturn tars, nil\n}\n\nfunc formatImageShaTag(registry string, function *stack.Function, sha string, owner string, repo string) string {\n\timageName := function.Image\n\n\trepoIndex := strings.LastIndex(imageName, \"/\")\n\tif repoIndex > -1 {\n\t\timageName = imageName[repoIndex+1:]\n\t}\n\n\tsha = sdk.FormatShortSHA(sha)\n\n\timageName = schema.BuildImageName(schema.BranchAndSHAFormat, imageName, sha, buildBranch())\n\n\tvar imageRef string\n\tsharedRepo := strings.HasSuffix(registry, \"/\")\n\tif sharedRepo {\n\t\timageRef = registry[:len(registry)-1] + \"/\" + owner + \"-\" + repo + \"-\" + imageName\n\t} else {\n\t\timageRef = registry + \"/\" + owner + \"/\" + repo + \"-\" + imageName\n\t}\n\n\treturn imageRef\n}\n\ntype githubAuthToken struct {\n\tappID          string\n\tinstallationID int\n\tprivateKeyPath string\n\ttoken          string\n}\n\nfunc (t *githubAuthToken) getToken() (string, error) {\n\tif t.token != \"\" {\n\t\treturn t.token, nil\n\t}\n\n\tprivateKey, ioErr := ioutil.ReadFile(t.privateKeyPath)\n\tif ioErr != nil {\n\t\treturn \"\", ioErr\n\t}\n\n\ttoken, err := auth.MakeAccessTokenForInstallation(t.appID, t.installationID, string(privateKey))\n\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\tt.token = token\n\n\treturn token, nil\n}\n\nfunc (t *githubAuthToken) getInstallationID() int {\n\treturn t.installationID\n}\n\ntype tokener interface {\n\tgetToken() (string, error)\n\tgetInstallationID() int\n}\n\nfunc getRepositoryURL(e sdk.PushEvent, authToken tokener) (string, error) {\n\tcu := e.Repository.CloneURL\n\n\tif e.Repository.Private {\n\t\tu, err := url.Parse(cu)\n\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"couldn't parse URL in getRepositoryURL: %t\", err)\n\t\t}\n\n\t\ttoken, err := authToken.getToken()\n\n\t\tif err != nil {\n\t\t\treturn \"\", fmt.Errorf(\"cannot get auth token: %t\", err)\n\t\t}\n\n\t\tiid := authToken.getInstallationID()\n\n\t\tu.User = url.UserPassword(strconv.Itoa(iid), token)\n\n\t\treturn u.String(), nil\n\t}\n\n\treturn cu, nil\n}\n\nfunc clone(pushEvent sdk.PushEvent) (string, error) {\n\tworkDir := os.TempDir()\n\tdestPath := path.Join(workDir, path.Join(pushEvent.Repository.Owner.Login, pushEvent.Repository.Name))\n\n\tif _, err := os.Stat(destPath); err == nil {\n\t\ttruncateErr := os.RemoveAll(destPath)\n\t\tif truncateErr != nil {\n\t\t\treturn \"\", truncateErr\n\t\t}\n\t}\n\n\tuserDir := path.Join(workDir, pushEvent.Repository.Owner.Login)\n\terr := os.MkdirAll(userDir, 0777)\n\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"cannot create user-dir: %s\", userDir)\n\t}\n\n\tvar cloneURL string\n\tvar cloneErr error\n\n\tswitch pushEvent.SCM {\n\tcase GitHub:\n\n\t\tcloneURL, cloneErr = GitHubCloneURL(pushEvent)\n\t\tif cloneErr != nil {\n\t\t\treturn \"\", fmt.Errorf(\"error while creating GitLab CloneURL: %s\", cloneErr.Error())\n\t\t}\n\n\tcase GitLab:\n\n\t\tif pushEvent.Repository.Private {\n\t\t\tcloneURL, cloneErr = GitLabCloneURL(pushEvent)\n\t\t\tif cloneErr != nil {\n\t\t\t\treturn \"\", fmt.Errorf(\"error while creating GitLab CloneURL: %s\", cloneErr.Error())\n\t\t\t}\n\t\t} else {\n\t\t\tcloneURL = pushEvent.Repository.CloneURL\n\t\t}\n\t}\n\n\tgit := exec.Command(\"git\", \"clone\", cloneURL)\n\tgit.Dir = path.Join(workDir, pushEvent.Repository.Owner.Login)\n\tlog.Println(git.Dir)\n\terr = git.Start()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Cannot start git: %t\", err)\n\t}\n\n\terr = git.Wait()\n\n\tgit = exec.Command(\"git\", \"checkout\", pushEvent.AfterCommitID)\n\tgit.Dir = destPath\n\terr = git.Start()\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"Cannot start git checkout: %t\", err)\n\t}\n\terr = git.Wait()\n\n\treturn destPath, err\n}\n\nfunc deploy(tars []tarEntry, pushEvent sdk.PushEvent, stack *stack.Services, status *sdk.Status, payloadSecret string) error {\n\n\tfailedFunctions := []string{}\n\towner := pushEvent.Repository.Owner.Login\n\n\tfor _, tarEntry := range tars {\n\n\t\tif isAWSECR(tarEntry.imageName) {\n\t\t\tlog.Printf(\"Registering image for %s: \", tarEntry.imageName)\n\n\t\t\terr := registerImage(tarEntry.imageName, payloadSecret)\n\t\t\tif err != nil {\n\t\t\t\t// This may be error due to already existing.\n\t\t\t\tlog.Printf(\"register-image failed: %s\\n\", err.Error())\n\t\t\t}\n\t\t}\n\n\t\terr := deployFunction(tarEntry, pushEvent, stack, status, payloadSecret)\n\n\t\tif err != nil {\n\t\t\tlog.Printf(\"%s\\n\", err.Error())\n\n\t\t\tfailedFunctions = append(failedFunctions, tarEntry.functionName)\n\t\t} else {\n\t\t\tlog.Printf(\"Service deployed: %s, owner: %s\\n\", tarEntry.functionName, owner)\n\t\t}\n\t}\n\n\tif len(failedFunctions) > 0 {\n\t\treturn fmt.Errorf(\"%s failed to be deployed via buildshiprun\", strings.Join(failedFunctions, \",\"))\n\t}\n\n\treturn nil\n}\n\nfunc deployFunction(tarEntry tarEntry, pushEvent sdk.PushEvent, stack *stack.Services, status *sdk.Status, payloadSecret string) error {\n\towner := pushEvent.Repository.Owner.Login\n\trepoName := pushEvent.Repository.Name\n\turl := pushEvent.Repository.CloneURL\n\tafterCommitID := pushEvent.AfterCommitID\n\tinstallationID := pushEvent.Installation.ID\n\tsourceManagement := pushEvent.SCM\n\tprivateRepo := pushEvent.Repository.Private\n\trepositoryURL := pushEvent.Repository.RepositoryURL\n\townerID := pushEvent.Repository.Owner.ID\n\n\tgatewayURL := os.Getenv(\"gateway_url\")\n\n\tlog.Printf(\"Deploying: %s, image: %s\\n\", tarEntry.functionName, tarEntry.imageName)\n\n\tstatus.AddStatus(sdk.StatusPending, fmt.Sprintf(\"%s function build started, image: %s\", tarEntry.functionName,\n\t\ttarEntry.imageName),\n\t\tsdk.BuildFunctionContext(tarEntry.functionName))\n\n\tstatusErr := reportStatus(status, pushEvent.SCM)\n\tif statusErr != nil {\n\t\tlog.Printf(statusErr.Error())\n\t}\n\n\tfileOpen, err := os.Open(tarEntry.fileName)\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tdefer fileOpen.Close()\n\n\tfileInfo, statErr := fileOpen.Stat()\n\tif statErr == nil {\n\t\tmsg := fmt.Sprintf(\"Building: %s, tar: %s\\n\",\n\t\t\ttarEntry.functionName,\n\t\t\tbytefmt.ByteSize(uint64(fileInfo.Size())))\n\n\t\tlog.Printf(\"%s\\n\", msg)\n\n\t\tauditEvent := sdk.AuditEvent{\n\t\t\tMessage: msg,\n\t\t\tOwner:   pushEvent.Repository.Owner.Login,\n\t\t\tRepo:    pushEvent.Repository.Name,\n\t\t\tSource:  Source,\n\t\t}\n\t\tsdk.PostAudit(auditEvent)\n\t}\n\n\ttarFileBytes, tarReadErr := ioutil.ReadAll(fileOpen)\n\tif tarReadErr != nil {\n\t\treturn tarReadErr\n\t}\n\n\tdigest := hmac.Sign(tarFileBytes, []byte(payloadSecret))\n\n\tpostBodyReader := bytes.NewReader(tarFileBytes)\n\n\thttpReq, _ := http.NewRequest(http.MethodPost, gatewayURL+\"function/buildshiprun\", postBodyReader)\n\n\thttpReq.Header.Add(sdk.CloudSignatureHeader, \"sha1=\"+hex.EncodeToString(digest))\n\n\thttpReq.Header.Add(\"Repo\", repoName)\n\thttpReq.Header.Add(\"Owner\", owner)\n\thttpReq.Header.Add(\"Url\", url)\n\thttpReq.Header.Add(\"Installation_id\", fmt.Sprintf(\"%d\", installationID))\n\thttpReq.Header.Add(\"Service\", tarEntry.functionName)\n\thttpReq.Header.Add(\"Image\", tarEntry.imageName)\n\thttpReq.Header.Add(\"Sha\", afterCommitID)\n\thttpReq.Header.Add(\"Scm\", sourceManagement)\n\thttpReq.Header.Add(\"Private\", strconv.FormatBool(privateRepo))\n\thttpReq.Header.Add(\"Repo-URL\", repositoryURL)\n\thttpReq.Header.Add(\"Owner-ID\", fmt.Sprintf(\"%d,\", ownerID))\n\n\tenvJSON, marshalErr := json.Marshal(stack.Functions[tarEntry.functionName].Environment)\n\tif marshalErr != nil {\n\t\tlog.Printf(\"Error marshaling %d env-vars for function: %s, error: %s\", len(stack.Functions[tarEntry.functionName].Environment), tarEntry.functionName, marshalErr)\n\t}\n\n\thttpReq.Header.Add(\"Env\", string(envJSON))\n\n\tsecretsJSON, marshalErr := json.Marshal(stack.Functions[tarEntry.functionName].Secrets)\n\tif marshalErr != nil {\n\t\tlog.Printf(\"Error marshaling secrets for function: %s, error: %s\", tarEntry.functionName, marshalErr)\n\t}\n\n\thttpReq.Header.Add(\"Secrets\", string(secretsJSON))\n\n\t// Marshal user labels\n\tif stack.Functions[tarEntry.functionName].Labels != nil {\n\t\tjsonBytes, marshalErr := json.Marshal(stack.Functions[tarEntry.functionName].Labels)\n\t\tif marshalErr != nil {\n\t\t\tlog.Printf(\"Error marshaling labels for function: %s, error: %s\", tarEntry.functionName, marshalErr)\n\t\t}\n\n\t\thttpReq.Header.Add(\"Labels\", string(jsonBytes))\n\t}\n\n\t// Marshal annotations\n\tif stack.Functions[tarEntry.functionName].Annotations != nil {\n\t\tjsonBytes, marshalErr := json.Marshal(stack.Functions[tarEntry.functionName].Annotations)\n\t\tif marshalErr != nil {\n\t\t\tlog.Printf(\"Error marshaling annotations for function: %s, error: %s\", tarEntry.functionName, marshalErr)\n\t\t}\n\n\t\thttpReq.Header.Add(\"Annotations\", string(jsonBytes))\n\t}\n\n\tres, reqErr := http.DefaultClient.Do(httpReq)\n\n\tif reqErr != nil {\n\t\treturn fmt.Errorf(\"unable to deploy function via buildshiprun: %s\", reqErr.Error())\n\t}\n\n\tif res.StatusCode != http.StatusOK && res.StatusCode != http.StatusAccepted {\n\t\treturn fmt.Errorf(\"unable to deploy function via buildshiprun: invalid status code: %d for %s\", res.StatusCode, tarEntry.functionName)\n\t}\n\n\treturn nil\n}\n\nfunc importSecrets(pushEvent sdk.PushEvent, stack *stack.Services, clonePath string) error {\n\tgatewayURL := os.Getenv(\"gateway_url\")\n\n\tsecretCount := 0\n\tfor _, fn := range stack.Functions {\n\t\tsecretCount += len(fn.Secrets)\n\t}\n\n\towner := pushEvent.Repository.Owner.Login\n\tsecretPath := path.Join(clonePath, \"secrets.yml\")\n\n\t// No secrets supplied.\n\tif fileInfo, err := os.Stat(secretPath); fileInfo == nil || err != nil {\n\t\treturn nil\n\t}\n\n\tbytesOut, err := ioutil.ReadFile(secretPath)\n\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to read secret: %s\", secretPath)\n\t}\n\n\tpayloadSecret, secretErr := sdk.ReadSecret(\"payload-secret\")\n\tif secretErr != nil {\n\t\treturn secretErr\n\t}\n\n\treader := bytes.NewReader(bytesOut)\n\thttpReq, _ := http.NewRequest(http.MethodPost, gatewayURL+\"function/import-secrets\", reader)\n\n\thttpReq.Header.Add(\"Owner\", owner)\n\n\tdigest := hmac.Sign(bytesOut, []byte(payloadSecret))\n\thttpReq.Header.Add(sdk.CloudSignatureHeader, \"sha1=\"+hex.EncodeToString(digest))\n\n\tres, reqErr := http.DefaultClient.Do(httpReq)\n\n\tif reqErr != nil {\n\t\tfmt.Fprintf(os.Stderr, fmt.Errorf(\"error reaching import-secrets function: %s\", reqErr.Error()).Error())\n\t}\n\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\n\tif res.StatusCode != http.StatusAccepted && res.StatusCode != http.StatusOK {\n\t\tif res.Body != nil {\n\t\t\tresBytes, err := ioutil.ReadAll(res.Body)\n\t\t\tif err != nil {\n\t\t\t\treturn fmt.Errorf(\"error reading response from import-secrets: %s\", err.Error())\n\t\t\t}\n\n\t\t\treturn fmt.Errorf(\"import-secrets returned unexpected status: %s\", string(resBytes))\n\n\t\t}\n\t\treturn fmt.Errorf(\"import-secrets returned unknown error, status: %d\", res.StatusCode)\n\t}\n\n\tauditEvent := sdk.AuditEvent{\n\t\tMessage: fmt.Sprintf(\"Parsed sealed secrets for owner: %s. Parsed %d secrets, from %d functions\", owner, secretCount, len(stack.Functions)),\n\t\tOwner:   pushEvent.Repository.Owner.Login,\n\t\tRepo:    pushEvent.Repository.Name,\n\t\tSource:  Source,\n\t}\n\n\tsdk.PostAudit(auditEvent)\n\n\tfmt.Println(\"Parsed sealed secrets\", res.Status, owner)\n\n\treturn nil\n}\n\nfunc formatTemplateRepos() []string {\n\ttemplateRepos := []string{\"https://github.com/openfaas/templates\"}\n\n\tif envTemplates := os.Getenv(\"custom_templates\"); len(envTemplates) > 0 {\n\t\tcustomTemplates := strings.Split(envTemplates, \",\")\n\t\tfor _, repo := range customTemplates {\n\t\t\tif strings.Contains(envTemplates, \"https://\") || strings.Contains(envTemplates, \"http://\") {\n\t\t\t\trepo = strings.Trim(repo, \" \")\n\t\t\t\ttemplateRepos = append(templateRepos, repo)\n\t\t\t} else {\n\t\t\t\tfmt.Println(\"Non-valid template URL is configured in custom_templates: \", repo)\n\t\t\t}\n\t\t}\n\t}\n\treturn templateRepos\n}\n\nfunc reportStatus(status *sdk.Status, SCM string) error {\n\tif SCM == GitHub {\n\t\treportGitHubStatus(status)\n\t} else if SCM == GitLab {\n\t\treportGitLabStatus(status)\n\t} else {\n\t\treturn fmt.Errorf(\"non-supported SCM: %s\", SCM)\n\t}\n\treturn nil\n}\n\nfunc reportGitLabStatus(status *sdk.Status) {\n\n\tpayloadSecret, secretErr := sdk.ReadSecret(\"payload-secret\")\n\tif secretErr != nil {\n\t\tlog.Printf(\"unexpected error while reading secret: %s\", secretErr)\n\t}\n\n\tsuffix := os.Getenv(\"dns_suffix\")\n\tgatewayURL := os.Getenv(\"gateway_url\")\n\tgatewayURL = sdk.CreateServiceURL(gatewayURL, suffix)\n\n\tstatusBytes, marshalErr := json.Marshal(status)\n\tif marshalErr != nil {\n\t\tlog.Printf(\"error while marshalling request: %s\", marshalErr.Error())\n\t}\n\n\tstatusReader := bytes.NewReader(statusBytes)\n\treq, reqErr := http.NewRequest(http.MethodPost, gatewayURL+\"function/gitlab-status\", statusReader)\n\tif reqErr != nil {\n\t\tlog.Printf(\"error while making request to gitlab-status: `%s`\", reqErr.Error())\n\t}\n\n\tdigest := hmac.Sign(statusBytes, []byte(payloadSecret))\n\treq.Header.Add(sdk.CloudSignatureHeader, \"sha1=\"+hex.EncodeToString(digest))\n\n\tres, resErr := http.DefaultClient.Do(req)\n\tif resErr != nil {\n\t\tlog.Printf(\"unexpected error while retrieving response: %s\", resErr.Error())\n\t}\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\tif res.StatusCode != http.StatusAccepted {\n\t\tlog.Printf(\"unexpected status code: %d\", res.StatusCode)\n\t}\n\n\t_, bodyErr := ioutil.ReadAll(res.Body)\n\tif bodyErr != nil {\n\t\tlog.Printf(\"unexpected error while reading response body: %s\", bodyErr.Error())\n\t}\n\tstatus.CommitStatuses = make(map[string]sdk.CommitStatus)\n}\n\nfunc reportGitHubStatus(status *sdk.Status) {\n\n\tif !enableStatusReporting() {\n\t\treturn\n\t}\n\n\thmacKey, keyErr := getPayloadSecret()\n\n\tif keyErr != nil {\n\t\tlog.Printf(\"failed to load hmac key for status, error \" + keyErr.Error())\n\n\t\treturn\n\t}\n\n\tgatewayURL := os.Getenv(\"gateway_url\")\n\n\t_, reportErr := status.Report(gatewayURL, hmacKey)\n\tif reportErr != nil {\n\t\tlog.Printf(\"failed to report status, error: %s\", reportErr.Error())\n\t}\n}\n\nfunc formatGitLabCloneURL(pushEvent sdk.PushEvent, tokenAPI string) (string, error) {\n\turl, urlErr := url.Parse(pushEvent.Repository.CloneURL)\n\tif urlErr != nil {\n\t\treturn \"\", fmt.Errorf(\"error while parsing URL: %s\", urlErr.Error())\n\t}\n\treturn fmt.Sprintf(\"https://%s:%s@%s%s\", pushEvent.Repository.Owner.Login, tokenAPI, url.Host, url.Path), nil\n}\n\n// GitLabCloneURL builds a URL from an sdk.PushEvent on how to clone a\n// GitLab repository\nfunc GitLabCloneURL(pushEvent sdk.PushEvent) (string, error) {\n\ttokenAPI, tokenErr := sdk.ReadSecret(\"gitlab-api-token\")\n\tif tokenErr != nil {\n\t\treturn \"\", fmt.Errorf(\"cannot read api token from GitLab in secret `gitlab-api-token`: %s\", tokenErr.Error())\n\t}\n\n\tcloneURL, formatErr := formatGitLabCloneURL(pushEvent, tokenAPI)\n\tif formatErr != nil {\n\t\treturn \"\", fmt.Errorf(\"error while formatting clone URL for GitLab: %s\", formatErr.Error())\n\t}\n\n\treturn cloneURL, nil\n}\n\n// GitHubCloneURL builds a URL from an sdk.PushEvent on how to clone a\n// GitHub repository\nfunc GitHubCloneURL(pushEvent sdk.PushEvent) (string, error) {\n\tat := &githubAuthToken{\n\t\tappID:          os.Getenv(\"github_app_id\"),\n\t\tinstallationID: pushEvent.Installation.ID,\n\t\tprivateKeyPath: sdk.GetPrivateKeyPath(),\n\t}\n\n\tcloneURL, err := getRepositoryURL(pushEvent, at)\n\tif err != nil {\n\t\treturn \"\", fmt.Errorf(\"cannot get repository url to clone: %t\", err)\n\t}\n\n\treturn cloneURL, nil\n}\n\nfunc checkCompatibleTemplates(stack *stack.Services, filePath string) (templatesErr error) {\n\ttemplates, ioErr := existingTemplates(filePath)\n\tif templatesErr != nil {\n\t\ttemplatesErr = ioErr\n\t}\n\tfor functionName, function := range stack.Functions {\n\t\tfor templateIndex, template := range templates {\n\t\t\tif template == function.Language {\n\t\t\t\tbreak\n\t\t\t} else if templateIndex == len(templates)-1 && template != function.Language {\n\t\t\t\ttemplatesErr = fmt.Errorf(\"Not supported language: `%s` for function: `%s`\",\n\t\t\t\t\tfunction.Language,\n\t\t\t\t\tfunctionName,\n\t\t\t\t)\n\t\t\t}\n\t\t}\n\t}\n\treturn templatesErr\n}\n\nfunc existingTemplates(filePath string) ([]string, error) {\n\tvar existingTemplates []string\n\ttemplatePath := fmt.Sprintf(\"%s/template\", filePath)\n\tfiles, ioErr := ioutil.ReadDir(templatePath)\n\tif ioErr != nil {\n\t\treturn nil, fmt.Errorf(\"error while reading tempates directory: %s\", ioErr)\n\t}\n\tfor _, templateFolder := range files {\n\t\tif templateFolder.IsDir() {\n\t\t\texistingTemplates = append(existingTemplates, templateFolder.Name())\n\t\t}\n\t}\n\treturn existingTemplates, nil\n}\n\nfunc isAWSECR(image string) bool {\n\treturn strings.Contains(image, \"amazonaws.com\")\n}\n\nfunc registerImage(image, payloadSecret string) error {\n\n\tpayloadBytes, marshalErr := json.Marshal(struct {\n\t\tImage string `json:\"image\"`\n\t}{\n\t\timage})\n\n\tif marshalErr != nil {\n\t\tlog.Printf(\"error while marshalling request: %s\", marshalErr.Error())\n\t}\n\n\tgatewayURL := os.Getenv(\"gateway_url\")\n\n\t_, body, err := invokeWithHMAC(gatewayURL+\"function/register-image\",\n\t\tpayloadBytes,\n\t\tpayloadSecret,\n\t\tmake(map[string]string))\n\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tlog.Println(body)\n\n\treturn err\n}\n\nfunc invokeWithHMAC(uri string, payload []byte, payloadSecret string, headers map[string]string) (int, []byte, error) {\n\n\tstatusReader := bytes.NewReader(payload)\n\treq, reqErr := http.NewRequest(http.MethodPost, uri, statusReader)\n\tif reqErr != nil {\n\t\tlog.Printf(\"error while making request to gitlab-status: `%s`\", reqErr.Error())\n\t}\n\n\tif headers != nil {\n\t\tfor k, v := range headers {\n\t\t\treq.Header.Add(k, v)\n\t\t}\n\t}\n\n\tif len(payloadSecret) > 0 {\n\t\tdigest := hmac.Sign(payload, []byte(payloadSecret))\n\t\treq.Header.Add(sdk.CloudSignatureHeader, \"sha1=\"+hex.EncodeToString(digest))\n\t}\n\n\tres, resErr := http.DefaultClient.Do(req)\n\tif resErr != nil {\n\t\tlog.Printf(\"unexpected error while retrieving response: %s\", resErr.Error())\n\t\treturn http.StatusServiceUnavailable, nil, resErr\n\t}\n\n\tif res.Body != nil {\n\t\tdefer res.Body.Close()\n\t}\n\n\tresOut, bodyErr := ioutil.ReadAll(res.Body)\n\tif bodyErr != nil {\n\t\tlog.Printf(\"unexpected error while reading response body: %s\", bodyErr.Error())\n\t}\n\n\tif res.StatusCode != http.StatusOK && res.StatusCode != http.StatusAccepted {\n\t\treturn res.StatusCode, resOut, fmt.Errorf(\"bad code: %d, message: %s\", res.StatusCode, string(resOut))\n\t}\n\n\treturn res.StatusCode, resOut, nil\n}\n","undoManager":{"mark":-1,"position":-1,"stack":[]},"ace":{"folds":[],"scrolltop":0,"scrollleft":0,"selection":{"start":{"row":490,"column":12},"end":{"row":490,"column":12},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":0},"timestamp":1574809855080}